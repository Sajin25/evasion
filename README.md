Evading Web Application Firewall (WAF) XSS Filters: A Python Approach
Introduction
In this project, we investigate how to evade Web Application Firewalls (WAFs) using obfuscated Cross-Site Scripting (XSS) payloads. The goal is to develop a Python script that generates XSS payloads capable of bypassing character-based filters commonly used by WAFs. This document will walk through the research, methodology, testing process, and results.

1. Web Application Firewalls (WAFs) Overview
1.1 What is a WAF?
A Web Application Firewall (WAF) is a security solution designed to protect web applications by filtering HTTP traffic. WAFs monitor, detect, and block malicious requests, especially targeting common vulnerabilities such as XSS, SQL Injection, and others.

1.2 WAF Mechanisms for Filtering XSS Attacks
XSS attacks typically involve the injection of malicious JavaScript into web pages, often using HTML or JavaScript elements. WAFs defend against these attacks by using:

Character-based filters that block certain characters such as <, >, ', and " commonly used in HTML or JavaScript.
Pattern-based detection for recognizing suspicious patterns in user input.
1.3 Challenges in Bypassing WAF Filters
Attackers attempt to bypass these WAF filters by obfuscating their payloads. This can involve:

Encoding: Converting payload characters into hexadecimal or URL-encoded forms.
Obfuscation: Inserting unexpected characters, spaces, or comments to bypass the filter.
Splitting payloads: Injecting code over multiple inputs to bypass single-field filtering.
2. Python Script for XSS Payload Generation
2.1 Purpose of the Script
The Python script developed here generates XSS payloads with different encoding and obfuscation techniques to evade common WAF character-based filters.
Payload Types
The script generates three different payload variations:

Original: The base payload (<script>alert('XSS');</script>)
Obfuscated: Payloads with additional comments (<!-- -->) to evade simple filters.
Hexadecimal Encoding: Payloads with characters encoded as hexadecimal.
HTML Entity Encoding: Payloads with HTML entities replacing characters.
3. Testing the Script
3.1 Test Environment
Web Application: A test environment such as OWASP Juice Shop was used.
WAF Implementation: ModSecurity with XSS filters enabled.
3.2 Payloads Tested
Payloads generated by the Python script were tested against the WAF-protected web application to determine which variations were successful in bypassing character-based filters.

3.3 Results
Payload Type	Blocked by WAF	Bypassed WAF
Original	Yes	No
Obfuscated	Yes	No
Hex Encoded	No	Yes
HTML Encoded	No	Yes
The hexadecimal and HTML-encoded payloads successfully bypassed the WAF, while the original and obfuscated versions were blocked.

3.4 Analysis of Results
The results indicate that simple character-based filters can be bypassed by encoding payloads in formats like hexadecimal or HTML entities. This is because these filters often look for specific character patterns (such as <script>) rather than encoded versions.

4. Conclusion
4.1 Key Findings
Character-based filters in WAFs are effective against simple XSS payloads but can be evaded through encoding and obfuscation techniques.
Hexadecimal and HTML entity encoding proved effective in bypassing the filters tested in this project.
4.2 Recommendations
Web developers should employ additional layers of defense, such as Content Security Policy (CSP) and input validation, rather than relying solely on WAFs to prevent XSS attacks.
WAFs should implement deeper inspection methods capable of decoding or normalizing input before applying filters.
5. Python Script and Documentation on GitHub
The Python script and testing documentation can be found on GitHub:https://github.com/Sajin25/evasion/blob/main/eva.py
